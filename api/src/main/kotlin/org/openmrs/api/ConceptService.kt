/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api

import org.openmrs.Concept
import org.openmrs.ConceptAnswer
import org.openmrs.ConceptAttribute
import org.openmrs.ConceptAttributeType
import org.openmrs.ConceptClass
import org.openmrs.ConceptComplex
import org.openmrs.ConceptDatatype
import org.openmrs.ConceptDescription
import org.openmrs.ConceptMap
import org.openmrs.ConceptMapType
import org.openmrs.ConceptName
import org.openmrs.ConceptNameTag
import org.openmrs.ConceptNumeric
import org.openmrs.ConceptProposal
import org.openmrs.ConceptReferenceRange
import org.openmrs.ConceptReferenceTerm
import org.openmrs.ConceptReferenceTermMap
import org.openmrs.ConceptSearchResult
import org.openmrs.ConceptSet
import org.openmrs.ConceptSource
import org.openmrs.ConceptStopWord
import org.openmrs.Drug
import org.openmrs.DrugIngredient
import org.openmrs.Person
import org.openmrs.annotation.Authorized
import org.openmrs.api.db.ConceptDAO
import org.openmrs.util.PrivilegeConstants
import java.util.Locale

/**
 * Contains methods pertaining to creating/updating/deleting/retiring Concepts, Drugs, Concept
 * Proposals, and all other things 'Concept'.
 *
 * To get a list of concepts:
 * ```
 * List<Concept> concepts = Context.getConceptService().getAllConcepts();
 * ```
 *
 * To get a single concept:
 * ```
 * // if there is a concept row in the database with concept_id = 3845
 * Concept concept = Context.getConceptService().getConcept(3845);
 * String name = concept.getPreferredName(Context.getLocale()).getName();
 * ```
 *
 * To save a concept to the database:
 * ```
 * Concept concept = new Concept();
 * concept.setConceptClass(Context.getConceptService().getConceptClass(3));
 * concept.setDatatype(Context.getConceptService().getConceptDatatype(17));
 * concept.setName...
 * ... // and other required values on the concept
 * Context.getConceptService().saveConcept(concept);
 * ```
 *
 * @see org.openmrs.api.context.Context
 */
interface ConceptService : OpenmrsService {

    /**
     * Sets the data access object for Concepts. The dao is used for saving and getting concepts
     * to/from the database
     *
     * @param dao The data access object to use
     */
    fun setConceptDAO(dao: ConceptDAO)

    /**
     * Get Concept by its UUID
     *
     * @param uuid
     * @return concept or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptByUuid(uuid: String): Concept?

    /**
     * Save or update the given Concept or ConceptNumeric in the database
     *
     * If this is a new concept, the returned concept will have a new conceptId
     * inserted into it that was generated by the database
     *
     * @param concept The Concept or ConceptNumeric to save or update
     * @return the Concept or ConceptNumeric that was saved or updated
     * @throws APIException
     * @throws ConceptsLockedException
     * @throws ConceptInUseException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun saveConcept(concept: Concept): Concept

    /**
     * Save or update the given Drug in the database. If this is a new drug, the
     * returned drug object will have a new drugId inserted into it that was
     * generated by the database
     *
     * @param drug The Drug to save or update
     * @return the Drug that was saved or updated
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun saveDrug(drug: Drug): Drug

    /**
     * Completely purge a Concept or ConceptNumeric from the database.
     * This should not typically be used unless desperately needed. Most should just be retired.
     *
     * @param conceptOrConceptNumeric The Concept or ConceptNumeric to remove from the system
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPTS)
    @Throws(APIException::class)
    fun purgeConcept(conceptOrConceptNumeric: Concept)

    /**
     * Retiring a concept essentially removes it from circulation
     *
     * @param conceptOrConceptNumeric The Concept or ConceptNumeric to retire
     * @param reason The retire reason
     * @return the retired Concept or ConceptNumeric
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun retireConcept(conceptOrConceptNumeric: Concept, reason: String): Concept

    /**
     * Retiring a Drug essentially removes it from circulation
     *
     * @param drug The Drug to retire
     * @param reason The retire reason
     * @return the retired Drug
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun retireDrug(drug: Drug, reason: String): Drug

    /**
     * Marks a drug that is currently retired as not retired.
     *
     * @param drug that is current set as retired
     * @return the given drug, marked as not retired now, and saved to the db
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun unretireDrug(drug: Drug): Drug

    /**
     * Completely purge a Drug from the database. This should not typically be used unless
     * desperately needed. Most Drugs should just be retired.
     *
     * @param drug The Drug to remove from the system
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPTS)
    @Throws(APIException::class)
    fun purgeDrug(drug: Drug)

    /**
     * Gets the concept with the given id
     *
     * @param conceptId
     * @return the matching Concept object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConcept(conceptId: Int?): Concept?

    /**
     * Gets the concept-name with the given id
     *
     * @param conceptNameId
     * @return the matching Concept object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptName(conceptNameId: Int?): ConceptName?

    /**
     * Gets the ConceptAnswer with the given id
     *
     * @param conceptAnswerId
     * @return the matching ConceptAnswer object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptAnswer(conceptAnswerId: Int?): ConceptAnswer?

    /**
     * Get the Drug with the given id
     *
     * @param drugId
     * @return the matching Drug object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrug(drugId: Int?): Drug?

    /**
     * Get the ConceptNumeric with the given id
     *
     * @param conceptId The ConceptNumeric id
     * @return the matching ConceptNumeric object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptNumeric(conceptId: Int?): ConceptNumeric?

    /**
     * Return a Concept class matching the given identifier
     *
     * @param conceptClassId the concept class identifier
     * @return the matching ConceptClass
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptClass(conceptClassId: Int?): ConceptClass?

    /**
     * Return a list of unretired concepts sorted by concept id ascending
     *
     * @return a List of all sorted concepts
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getAllConcepts(): List<Concept>

    /**
     * Return a list of concepts sorted on sortBy in dir direction (asc/desc)
     *
     * @param sortBy The property name to sort by; if null or invalid, concept_id is used.
     * @param asc true = sort ascending; false = sort descending
     * @param includeRetired If true, retired concepts will also be returned
     * @return a List of all sorted concepts
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getAllConcepts(sortBy: String?, asc: Boolean, includeRetired: Boolean): List<Concept>

    /**
     * Returns a list of concepts matching any part of a concept name, this method is case
     * insensitive to the concept name string
     *
     * @param name The search string
     * @return a List of all matching concepts
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByName(name: String): List<Concept>

    /**
     * Return a Concept that matches the name exactly
     *
     * @param name The search string
     * @return the found Concept
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptByName(name: String?): Concept?

    /**
     * Get Concept by id or name convenience method
     *
     * @param conceptIdOrName
     * @return the found Concept
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConcept(conceptIdOrName: String?): Concept?

    /**
     * Get the concept by conceptRef where the conceptRef can either be:
     * 1) an integer id like 5090
     * 2) a mapping type id like "XYZ:HT"
     * 3) a uuid like "a3e12268-74bf-11df-9768-17cfc9833272"
     * 4) a name like "PLATELETS"
     * 5) the fully qualified name of a Java constant which contains one of the above
     *
     * @param conceptRef the concept string identifier
     * @return the concept if it exists otherwise null
     * @since 2.6.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptByReference(conceptRef: String?): Concept?

    /**
     * Get Drug by its UUID
     *
     * @param uuid
     * @return drug or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getDrugByUuid(uuid: String): Drug?

    /**
     * Get Drug Ingredient by its UUID
     *
     * @param uuid the uuid for the drug ingredient to get
     * @return the drug ingredient if found, else null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getDrugIngredientByUuid(uuid: String): DrugIngredient?

    /**
     * Return the drug object corresponding to the given name or drugId
     *
     * @param drugNameOrId String name or drugId to match exactly on
     * @return matching Drug object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrug(drugNameOrId: String): Drug?

    /**
     * Return a list of drugs currently in the database that are not retired
     *
     * @return a List of all drugs
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getAllDrugs(): List<Drug>

    /**
     * Return a list of drugs associated with the given concept
     *
     * @param concept
     * @return a List of all matching drugs
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrugsByConcept(concept: Concept): List<Drug>

    /**
     * Get drugs by concept. This method is the utility method that should be used to generically
     * retrieve all Drugs in the system.
     *
     * @param includeRetired If true then the search will include voided Drugs
     * @return A List of all matching Drugs
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getAllDrugs(includeRetired: Boolean): List<Drug>

    /**
     * Find drugs in the system. The string search can match either drug.name or drug.concept.name,
     * drug.drugId or drug.concept.conceptId
     *
     * @param phrase Search phrase
     * @return A List of all Drug matches
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrugs(phrase: String): List<Drug>

    /**
     * @param cc ConceptClass
     * @return Returns all concepts in a given class
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByClass(cc: ConceptClass): List<Concept>

    /**
     * Return a Concept class matching the given name
     *
     * @param name
     * @return ConceptClass matching the given name
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
    @Throws(APIException::class)
    fun getConceptClassByName(name: String): ConceptClass?

    /**
     * Return a list of concept classes currently in the database
     *
     * @return List of all ConceptClass objects
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
    @Throws(APIException::class)
    fun getAllConceptClasses(): List<ConceptClass>

    /**
     * Return a list of concept classes currently in the database
     *
     * @param includeRetired include retired concept classes in the search results?
     * @return List of all ConceptClass objects
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
    @Throws(APIException::class)
    fun getAllConceptClasses(includeRetired: Boolean): List<ConceptClass>

    /**
     * Get ConceptClass by its UUID
     *
     * @param uuid
     * @return concept class or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
    fun getConceptClassByUuid(uuid: String): ConceptClass?

    /**
     * Get ConceptAnswer by its UUID
     *
     * @param uuid
     * @return concept answer or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptAnswerByUuid(uuid: String): ConceptAnswer?

    /**
     * Get ConceptName by its UUID
     *
     * @param uuid
     * @return concept name or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptNameByUuid(uuid: String): ConceptName?

    /**
     * Get ConceptSet by its UUID
     *
     * @param uuid
     * @return concept set or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptSetByUuid(uuid: String): ConceptSet?

    /**
     * Get ConceptSource by its UUID
     *
     * @param uuid
     * @return concept source or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
    fun getConceptSourceByUuid(uuid: String): ConceptSource?

    /**
     * Creates or updates a concept class
     *
     * @param cc ConceptClass to create or update
     * @return the saved ConceptClass
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_CLASSES)
    @Throws(APIException::class)
    fun saveConceptClass(cc: ConceptClass): ConceptClass

    /**
     * Purge a ConceptClass
     *
     * @param cc ConceptClass to delete
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_CLASSES)
    @Throws(APIException::class)
    fun purgeConceptClass(cc: ConceptClass)

    /**
     * Purge a ConceptNameTag
     *
     * @param cnt ConceptNameTag to delete
     * @throws APIException
     * @since 1.10
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_NAME_TAGS)
    @Throws(APIException::class)
    fun purgeConceptNameTag(cnt: ConceptNameTag)

    /**
     * Return a list of all concept datatypes currently in the database
     *
     * @return List of ConceptDatatypes
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
    @Throws(APIException::class)
    fun getAllConceptDatatypes(): List<ConceptDatatype>

    /**
     * Return a list of concept datatypes currently in the database
     *
     * @param includeRetired boolean - include the retired datatypes?
     * @return List of ConceptDatatypes
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
    @Throws(APIException::class)
    fun getAllConceptDatatypes(includeRetired: Boolean): List<ConceptDatatype>

    /**
     * Return a ConceptDatatype matching the given identifier
     *
     * @param i Integer for the requested ConceptDatatype
     * @return ConceptDatatype matching the given identifier
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
    @Throws(APIException::class)
    fun getConceptDatatype(i: Int?): ConceptDatatype?

    /**
     * Get ConceptDatatype by its UUID
     *
     * @param uuid
     * @return concept data type or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
    fun getConceptDatatypeByUuid(uuid: String): ConceptDatatype?

    /**
     * Return a Concept datatype matching the given name
     *
     * @param name
     * @return ConceptDatatype matching the given name
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
    @Throws(APIException::class)
    fun getConceptDatatypeByName(name: String): ConceptDatatype?

    /**
     * Return a list of the concept sets with concept_set matching concept
     *
     * For example to find all concepts for ARVs, you would do
     * getConceptSets(getConcept("ANTIRETROVIRAL MEDICATIONS")) and then take the conceptIds from
     * the resulting list.
     *
     * @param concept The concept representing the concept set
     * @return A List of matching ConceptSets
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptSetsByConcept(concept: Concept): List<ConceptSet>

    /**
     * Return a List of all concepts within a concept set
     *
     * @param concept The concept representing the concept set
     * @return A List of all objects within the ConceptSet
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByConceptSet(concept: Concept): List<Concept>

    /**
     * Find all sets that the given concept is a member of
     *
     * @param concept
     * @return A List with all parent concept sets
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getSetsContainingConcept(concept: Concept?): List<ConceptSet>

    /**
     * Get a List of all concept proposals
     *
     * @param includeCompleted boolean - include completed proposals as well?
     * @return a List of all found ConceptProposals
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
    @Throws(APIException::class)
    fun getAllConceptProposals(includeCompleted: Boolean): List<ConceptProposal>

    /**
     * Get ConceptNumeric by its UUID
     *
     * @param uuid
     * @return concept numeric or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptNumericByUuid(uuid: String): ConceptNumeric?

    /**
     * Get a ConceptProposal by conceptProposalId
     *
     * @param conceptProposalId the Integer concept proposal Id
     * @return the found ConceptProposal
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
    @Throws(APIException::class)
    fun getConceptProposal(conceptProposalId: Int?): ConceptProposal?

    /**
     * Find matching concept proposals
     *
     * @param text
     * @return a List of matching concept proposals
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
    @Throws(APIException::class)
    fun getConceptProposals(text: String): List<ConceptProposal>

    /**
     * Find matching proposed concepts
     *
     * @param text
     * @return a List of matching proposed concepts
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
    @Throws(APIException::class)
    fun getProposedConcepts(text: String): List<Concept>

    /**
     * Saves/updates/proposes a concept proposal
     *
     * @param conceptProposal The ConceptProposal to save
     * @return the saved/updated ConceptProposal object
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.ADD_CONCEPT_PROPOSALS, PrivilegeConstants.EDIT_CONCEPT_PROPOSALS)
    @Throws(APIException::class)
    fun saveConceptProposal(conceptProposal: ConceptProposal): ConceptProposal

    /**
     * Removes a concept proposal from the database entirely.
     *
     * @param cp
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_PROPOSALS)
    @Throws(APIException::class)
    fun purgeConceptProposal(cp: ConceptProposal)

    /**
     * Maps a concept proposal to a concept
     *
     * @param cp
     * @param mappedConcept
     * @return the mappedConcept
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun mapConceptProposalToConcept(cp: ConceptProposal, mappedConcept: Concept?): Concept

    /**
     * Maps a concept proposal to a concept
     *
     * @param cp
     * @param mappedConcept
     * @param locale of concept proposal
     * @return the mappedConcept
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun mapConceptProposalToConcept(cp: ConceptProposal, mappedConcept: Concept?, locale: Locale): Concept

    /**
     * Returns all possible Concepts to which this concept is a value-coded answer. To navigate in
     * the other direction, i.e., from Concept to its answers use Concept.getAnswers()
     *
     * @param concept
     * @return A List containing all possible questions to which this concept is a valued_Coded answer
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByAnswer(concept: Concept): List<Concept>

    /**
     * Finds the previous concept in the dictionary that has the next lowest concept id
     *
     * @param concept the offset Concept
     * @return the foundConcept
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getPrevConcept(concept: Concept): Concept?

    /**
     * Finds the next concept in the dictionary that has the next largest concept id
     *
     * @param concept the offset Concept
     * @return the foundConcept
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getNextConcept(concept: Concept): Concept?

    /**
     * Check if the concepts are locked and if so, throw exception during manipulation of concept
     *
     * @throws ConceptsLockedException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(ConceptsLockedException::class)
    fun checkIfLocked()

    /**
     * Get ConceptProposal by its UUID
     *
     * @param uuid
     * @return concept proposal or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
    fun getConceptProposalByUuid(uuid: String): ConceptProposal?

    /**
     * Convenience method for finding concepts associated with drugs in formulary.
     *
     * @return A List of all concepts that occur as a Drug.concept.
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsWithDrugsInFormulary(): List<Concept>

    /**
     * Get ConceptNameTag by its UUID
     *
     * @param uuid
     * @return the conceptNameTag with a matching uuid
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptNameTagByUuid(uuid: String): ConceptNameTag?

    /**
     * Get a ComplexConcept with the given conceptId
     *
     * @param conceptId of the ComplexConcept
     * @return a ConceptComplex object
     * @since 1.5
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptComplex(conceptId: Int?): ConceptComplex?

    /**
     * Search for a ConceptNameTag by name
     *
     * @param tag String name of ConceptNameTag
     * @return ConceptNameTag matching the given String tag
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptNameTagByName(tag: String): ConceptNameTag?

    /**
     * Gets the set of unique Locales used by existing concept names.
     *
     * @return set of used Locales
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getLocalesOfConceptNames(): Set<Locale>

    /**
     * Return a list of concept sources currently in the database
     * Whether or not to return retired concept sources is decided by the boolean includeRetired param
     *
     * @param includeRetired whether or not to include retired sources
     * @return List of Concept source objects
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun getAllConceptSources(includeRetired: Boolean): List<ConceptSource>

    /**
     * Return a Concept source matching the given concept source id
     *
     * @param i Integer conceptSourceId
     * @return ConceptSource
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun getConceptSource(i: Int?): ConceptSource?

    /**
     * Create a new ConceptSource
     *
     * @param conceptSource ConceptSource to create
     * @return the saved ConceptSource
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun saveConceptSource(conceptSource: ConceptSource): ConceptSource

    /**
     * Delete ConceptSource
     *
     * @param cs ConceptSource object delete
     * @return the deleted ConceptSource
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun purgeConceptSource(cs: ConceptSource): ConceptSource

    /**
     * This effectively removes a concept source from the database. The source can still be
     * referenced by old data, but no new data should use this source.
     *
     * @param cs the concept source to retire
     * @param reason why the concept source is to be retired, must not be empty of null
     * @return the retired concept source
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun retireConceptSource(cs: ConceptSource, reason: String): ConceptSource

    /**
     * Creates a new Concept name tag if none exists. If a tag exists with the same name then that
     * existing tag is returned.
     *
     * @param nameTag the concept name tag to be saved
     * @return the newly created or existing concept name tag
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_NAME_TAGS)
    fun saveConceptNameTag(nameTag: ConceptNameTag): ConceptNameTag?

    /**
     * Gets the highest concept-id used by a concept.
     *
     * @return highest concept-id
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getMaxConceptId(): Int?

    /**
     * Returns an iterator for all concepts, including retired and expired.
     *
     * @return the Iterator
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun conceptIterator(): Iterator<Concept>

    /**
     * Looks up a concept via ConceptMap
     *
     * @param code the code associated with a concept within a given ConceptSource
     * @param sourceName the name or hl7Code of the ConceptSource to check
     * @return the Concept that has the given mapping, or null if no Concept found
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptByMapping(code: String, sourceName: String): Concept?

    /**
     * Looks up a concept via ConceptMap
     *
     * @param code the code associated with a concept within a given ConceptSource
     * @param sourceName the name or hl7Code of the ConceptSource to check
     * @param includeRetired whether or not to include retired concepts
     * @return the Concept that has the given mapping, or null if no Concept found
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptByMapping(code: String, sourceName: String, includeRetired: Boolean?): Concept?

    /**
     * Looks up concepts via ConceptMap
     *
     * @param code the code associated with a concept within a given ConceptSource
     * @param sourceName the name or hl7Code of the ConceptSource to check
     * @return the list of non-voided Concepts that has the given mapping, or null if no Concept found
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByMapping(code: String, sourceName: String): List<Concept>

    /**
     * Looks up concepts via ConceptMap
     *
     * @param code the code associated with a concept within a given ConceptSource
     * @param sourceName the name or hl7Code of the ConceptSource to check
     * @param includeRetired whether or not to include retired concepts
     * @return the list of non-voided Concepts that has the given mapping, or null if no Concept found
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByMapping(code: String, sourceName: String, includeRetired: Boolean): List<Concept>

    /**
     * Looks up concepts via ConceptMap
     *
     * @param code the code associated with a concept within a given ConceptSource
     * @param sourceName the name or hl7Code of the ConceptSource to check
     * @param includeRetired whether or not to include retired concepts
     * @return the list ids for all non-voided Concepts that have the given mapping, or an empty List if none found
     * @throws APIException
     * @since 2.3
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptIdsByMapping(code: String, sourceName: String, includeRetired: Boolean): List<Int>

    /**
     * Get all the concept name tags defined in the database, included voided ones
     *
     * @return a list of the concept name tags stored in the dataset
     * @since 1.5
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getAllConceptNameTags(): List<ConceptNameTag>

    /**
     * Gets the ConceptNameTag with the given database primary key
     *
     * @param id the concept name tag id to find
     * @return the matching ConceptNameTag or null if none found
     * @since 1.5
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptNameTag(id: Int?): ConceptNameTag?

    /**
     * Get ConceptDescription by its UUID
     *
     * @param uuid
     * @return concept description or null
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptDescriptionByUuid(uuid: String): ConceptDescription?

    /**
     * Lookup a ConceptSource by its name property
     *
     * @param conceptSourceName
     * @return ConceptSource
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun getConceptSourceByName(conceptSourceName: String): ConceptSource?

    /**
     * Get a ConceptSource by its unique id.
     *
     * @param uniqueId the unique id
     * @return the concept source matching given unique id
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun getConceptSourceByUniqueId(uniqueId: String?): ConceptSource?

    /**
     * Get a ConceptSource by its hl7Code.
     *
     * @param hl7Code the hl7Code
     * @return the concept source matching given hl7Code
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
    @Throws(APIException::class)
    fun getConceptSourceByHL7Code(hl7Code: String?): ConceptSource?

    /**
     * Checks if there are any observations (including voided observations) for a concept.
     *
     * @param concept which used or not used by an observation
     * @return boolean true if the concept is used by an observation
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun hasAnyObservation(concept: Concept): Boolean

    /**
     * Returns the TRUE concept
     *
     * @return true concept
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getTrueConcept(): Concept?

    /**
     * Returns the FALSE concept
     *
     * @return false concept
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getFalseConcept(): Concept?

    /**
     * Returns the UNKNOWN concept
     *
     * @return unknown concept
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getUnknownConcept(): Concept?

    /**
     * Changes the datatype of a concept from boolean to coded when it has observations it is
     * associated to.
     *
     * @param conceptToChange the concept which to change
     * @throws APIException
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun convertBooleanConceptToCoded(conceptToChange: Concept)

    /**
     * Checks if there are any observations (including voided observations) using a conceptName.
     *
     * @param conceptName which is used or not used by an observation
     * @return boolean true if the conceptName is used by an observation otherwise false
     * @throws APIException
     * @since Version 1.7
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun hasAnyObservation(conceptName: ConceptName): Boolean

    /**
     * Searches for concepts by the given parameters.
     *
     * @param phrase matched to the start of any word in any of the names of a concept (if blank/null, matches all concepts)
     * @param locales List to restrict to
     * @param includeRetired boolean if false, will exclude retired concepts
     * @param requireClasses List to restrict to
     * @param excludeClasses List to leave out of results
     * @param requireDatatypes List to restrict to
     * @param excludeDatatypes List to leave out of results
     * @param answersToConcept all results will be a possible answer to this concept
     * @param start all results less than this number will be removed
     * @param size if non zero, all results after start + size will be removed
     * @return a list of conceptSearchResults
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConcepts(
        phrase: String?,
        locales: @JvmSuppressWildcards List<Locale>?,
        includeRetired: Boolean,
        requireClasses: @JvmSuppressWildcards List<ConceptClass>?,
        excludeClasses: @JvmSuppressWildcards List<ConceptClass>?,
        requireDatatypes: @JvmSuppressWildcards List<ConceptDatatype>?,
        excludeDatatypes: @JvmSuppressWildcards List<ConceptDatatype>?,
        answersToConcept: Concept?,
        start: Int?,
        size: Int?
    ): List<ConceptSearchResult>

    /**
     * Finds concepts that are possible value coded answers to concept parameter
     *
     * @param phrase
     * @param locale
     * @param concept the answers to match on
     * @return a list of conceptSearchResults
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun findConceptAnswers(phrase: String?, locale: Locale, concept: Concept): List<ConceptSearchResult>

    /**
     * Iterates over the words in names and synonyms (for each locale) and updates the concept
     * index, note that this only updates the index of the specified concept.
     *
     * @param concept the concept whose index is to be updated
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun updateConceptIndex(concept: Concept)

    /**
     * Iterates over all concepts and calls updateConceptIndexes(Concept concept)
     *
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    @Throws(APIException::class)
    fun updateConceptIndexes()

    /**
     * Searches for concepts with the given parameters
     *
     * @param phrase the string to search against (if blank/null, matches all concepts)
     * @param locale the locale in which to search for the concepts
     * @param includeRetired Specifies whether to include retired concepts
     * @return a list ConceptSearchResults
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConcepts(phrase: String?, locale: Locale, includeRetired: Boolean): List<ConceptSearchResult>

    /**
     * Return the number of concepts matching a search phrase and the specified arguments
     *
     * @param phrase matched to the start of any word in any of the names of a concept
     * @param locales List to restrict to
     * @param includeRetired Specifies whether to include retired concepts
     * @param requireClasses List to restrict to
     * @param excludeClasses List to leave out of results
     * @param requireDatatypes List to restrict to
     * @param excludeDatatypes List to leave out of results
     * @param answersToConcept all results will be a possible answer to this concept
     * @return the number of concepts matching the given search phrase
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getCountOfConcepts(
        phrase: String?,
        locales: @JvmSuppressWildcards List<Locale>?,
        includeRetired: Boolean,
        requireClasses: @JvmSuppressWildcards List<ConceptClass>?,
        excludeClasses: @JvmSuppressWildcards List<ConceptClass>?,
        requireDatatypes: @JvmSuppressWildcards List<ConceptDatatype>?,
        excludeDatatypes: @JvmSuppressWildcards List<ConceptDatatype>?,
        answersToConcept: Concept?
    ): Int?

    /**
     * Return the number of drugs with matching names or concept drug names
     *
     * @param drugName the name of the drug
     * @param concept the drug concept
     * @param searchOnPhrase Specifies if the search should match names starting with or contain the text
     * @param searchDrugConceptNames Specifies whether a search on concept names for the drug's concept should be done or not
     * @param includeRetired specifies whether to include retired drugs
     * @return the number of matching drugs
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getCountOfDrugs(
        drugName: String?,
        concept: Concept?,
        searchOnPhrase: Boolean,
        searchDrugConceptNames: Boolean,
        includeRetired: Boolean
    ): Int?

    /**
     * Returns a list of drugs with matching names or concept drug names and returns a specific
     * number of them from the specified starting position.
     *
     * @param drugName the name of the drug
     * @param concept the drug concept
     * @param searchKeywords Specifies whether the search should match keywords or just phrase
     * @param searchDrugConceptNames Specifies whether a search on concept names for the drug's concept should be done or not
     * @param includeRetired specifies whether to include retired drugs
     * @param start beginning index for the batch
     * @param length number of drugs to return in the batch
     * @return a list of matching drugs
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrugs(
        drugName: String?,
        concept: Concept?,
        searchKeywords: Boolean,
        searchDrugConceptNames: Boolean,
        includeRetired: Boolean,
        start: Int?,
        length: Int?
    ): List<Drug>

    /**
     * Gets the list of ConceptStopWord for given locale
     *
     * @param locale The locale in which to search for the ConceptStopWord
     * @return list of concept stop words for given locale
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptStopWords(locale: Locale?): List<String>

    /**
     * Save the given ConceptStopWord in the database
     *
     * @param conceptStopWord The ConceptStopWord to save or update
     * @return the ConceptStopWord that was saved or updated
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_STOP_WORDS)
    @Throws(APIException::class)
    fun saveConceptStopWord(conceptStopWord: ConceptStopWord): ConceptStopWord

    /**
     * Delete the given ConceptStopWord in the database
     *
     * @param conceptStopWordId The ConceptStopWord to delete
     * @throws APIException
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_STOP_WORDS)
    @Throws(APIException::class)
    fun deleteConceptStopWord(conceptStopWordId: Int?)

    /**
     * Get all the concept stop words
     *
     * @return List of ConceptStopWord
     * @since 1.8
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getAllConceptStopWords(): List<ConceptStopWord>

    /**
     * Gets drugs by the given ingredient, which can be either the drug itself or any ingredient.
     *
     * @return the list of drugs
     * @since 1.10
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getDrugsByIngredient(ingredient: Concept): List<Drug>

    /**
     * Returns a list of concept map types currently in the database excluding hidden ones
     *
     * @return List of concept map type objects
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun getActiveConceptMapTypes(): List<ConceptMapType>

    /**
     * Returns a list of concept map types currently in the database including or excluding retired
     * and hidden ones as specified by the includeRetired and includeHidden arguments
     *
     * @param includeRetired specifies if retired concept map types should be included
     * @param includeHidden specifies if hidden concept map types should be included
     * @return List of concept map type objects
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun getConceptMapTypes(includeRetired: Boolean, includeHidden: Boolean): List<ConceptMapType>

    /**
     * Return a concept map type matching the given concept map type id
     *
     * @param conceptMapTypeId Integer concept map type id
     * @return ConceptMapType
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun getConceptMapType(conceptMapTypeId: Int?): ConceptMapType?

    /**
     * Return a concept map type matching the given uuid
     *
     * @param uuid the uuid to search against
     * @return ConceptMapType
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun getConceptMapTypeByUuid(uuid: String): ConceptMapType?

    /**
     * Return a concept map type matching the given name
     *
     * @param name the name to search against
     * @return ConceptMapType
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun getConceptMapTypeByName(name: String): ConceptMapType?

    /**
     * Saves or updates the specified concept map type in the database
     *
     * @param conceptMapType the concept map type to save
     * @return the saved conceptMapType
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun saveConceptMapType(conceptMapType: ConceptMapType): ConceptMapType

    /**
     * Retiring a concept map type essentially removes it from circulation
     *
     * @param conceptMapType the concept map type to retire
     * @param retireReason the reason why the concept map type is being retired
     * @return the retired concept map type
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun retireConceptMapType(conceptMapType: ConceptMapType, retireReason: String?): ConceptMapType

    /**
     * Marks a concept map type that is currently retired as not retired.
     *
     * @param conceptMapType the concept map type to unretire
     * @return the unretired concept map type
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun unretireConceptMapType(conceptMapType: ConceptMapType): ConceptMapType

    /**
     * Completely purges a concept map type from the database
     *
     * @param conceptMapType the concept map type to purge from the database
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun purgeConceptMapType(conceptMapType: ConceptMapType)

    /**
     * Returns a list of mappings from concepts to terms in the given reference terminology
     *
     * @param conceptSource
     * @return a List of ConceptMaps
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptMappingsToSource(conceptSource: ConceptSource): List<ConceptMap>

    /**
     * Gets a list of all concept reference terms saved in the database
     *
     * @return a list of concept reference terms
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getAllConceptReferenceTerms(): List<ConceptReferenceTerm>

    /**
     * Gets a list of concept reference terms saved in the database
     *
     * @param includeRetired specifies if retired concept reference terms should be included
     * @return a list of concept reference terms
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTerms(includeRetired: Boolean): List<ConceptReferenceTerm>

    /**
     * Gets the concept reference term with the specified concept reference term id
     *
     * @param conceptReferenceTermId the concept reference term id to search against
     * @return the concept reference term object with the given concept reference term id
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTerm(conceptReferenceTermId: Int?): ConceptReferenceTerm?

    /**
     * Gets the concept reference term with the specified uuid
     *
     * @param uuid the uuid to search against
     * @return the concept reference term object with the given uuid
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTermByUuid(uuid: String): ConceptReferenceTerm?

    /**
     * Gets a concept reference term with the specified name from the specified concept source
     * ignoring all retired ones
     *
     * @param name the name to match against
     * @param conceptSource the concept source to match against
     * @return concept reference term object
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTermByName(name: String, conceptSource: ConceptSource): ConceptReferenceTerm?

    /**
     * Gets a concept reference term with the specified code from the specified concept source
     *
     * @param code the code to match against
     * @param conceptSource the concept source to match against
     * @return concept reference term object
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTermByCode(code: String, conceptSource: ConceptSource): ConceptReferenceTerm?

    /**
     * Gets a list of concept reference terms with the specified code from the specified concept source
     *
     * @param code the code to match against
     * @param conceptSource the concept source to match against
     * @param includeRetired specifies if retired concept reference terms should be included
     * @return list of concept reference term objects
     * @throws APIException
     * @since 2.7
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTermByCode(code: String, conceptSource: ConceptSource, includeRetired: Boolean): List<ConceptReferenceTerm>

    /**
     * Stores the specified concept reference term to the database
     *
     * @param conceptReferenceTerm the concept reference term object to save
     * @return the saved concept reference term object
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun saveConceptReferenceTerm(conceptReferenceTerm: ConceptReferenceTerm): ConceptReferenceTerm

    /**
     * Retiring a concept reference term essentially removes it from circulation
     *
     * @param conceptReferenceTerm the concept reference term object to retire
     * @param retireReason the reason why the concept reference term is being retired
     * @return the retired concept reference term object
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun retireConceptReferenceTerm(conceptReferenceTerm: ConceptReferenceTerm, retireReason: String?): ConceptReferenceTerm

    /**
     * Marks a concept reference term that is currently retired as not retired.
     *
     * @param conceptReferenceTerm the concept reference term to unretire
     * @return the unretired concept reference term
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun unretireConceptReferenceTerm(conceptReferenceTerm: ConceptReferenceTerm): ConceptReferenceTerm

    /**
     * Purges the specified concept reference term from the database
     *
     * @param conceptReferenceTerm the concept reference term object to purge
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun purgeConceptReferenceTerm(conceptReferenceTerm: ConceptReferenceTerm)

    /**
     * Finds the concept reference term in the database that have a code or name that contains the
     * specified search phrase.
     *
     * @param query the string to match against the reference term names or codes
     * @param conceptSource the concept source from which the terms should be looked up
     * @param start beginning index for the batch
     * @param length number of terms to return in the batch
     * @param includeRetired specifies if the retired terms should be included
     * @return a list if ConceptReferenceTerms
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getConceptReferenceTerms(
        query: String,
        conceptSource: ConceptSource?,
        start: Int?,
        length: Int?,
        includeRetired: Boolean
    ): List<ConceptReferenceTerm>

    /**
     * Returns the count of concept reference terms that match the specified arguments
     *
     * @param query the string to match against the reference term names
     * @param conceptSource the concept source from which the terms should be looked up
     * @param includeRetired specifies if retired concept reference terms should be included
     * @return the count of matching concept reference terms
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getCountOfConceptReferenceTerms(query: String, conceptSource: ConceptSource?, includeRetired: Boolean): Int?

    /**
     * Fetches all the ConceptReferenceTermMap where the specified reference term is the termB
     *
     * @param term the term to match against
     * @return a list of ConceptReferenceTermMaps
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
    @Throws(APIException::class)
    fun getReferenceTermMappingsTo(term: ConceptReferenceTerm): List<ConceptReferenceTermMap>

    /**
     * Returns a list of concepts with the same name in the given locale.
     *
     * @param name
     * @param locale null = all locales
     * @param exactLocale false if search for both global and country specific, true if null
     * @return the list of concepts
     * @throws APIException
     * @since 1.9, 1.8.4
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getConceptsByName(name: String, locale: Locale?, exactLocale: Boolean?): List<Concept>

    /**
     * Gets the concept map type to be used as the default. It is specified by the
     * concept.defaultConceptMapType global property.
     *
     * @return the ConceptMapType
     * @throws APIException
     * @since 1.9
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
    @Throws(APIException::class)
    fun getDefaultConceptMapType(): ConceptMapType?

    /**
     * Determines if the given concept name is a duplicate.
     *
     * @param name
     * @return true if it is a duplicate name
     * @since 1.11
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun isConceptNameDuplicate(name: ConceptName): Boolean

    /**
     * Fetches un retired drugs that match the specified search phrase.
     *
     * @param searchPhrase The string to match against
     * @param locale The locale to match against when searching in drug concept names
     * @param exactLocale If false then concepts with names in a broader locale will be matched
     * @param includeRetired Specifies if retired drugs that match should be included or not
     * @return A list of matching drugs
     * @since 1.10
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getDrugs(searchPhrase: String, locale: Locale, exactLocale: Boolean, includeRetired: Boolean): List<Drug>

    /**
     * Fetches all drugs with reference mappings to the specified concept source that match the
     * specified code and concept map types
     *
     * @param code the code the reference term code to match on
     * @param conceptSource the concept source on which to match on
     * @param withAnyOfTheseTypes the ConceptMapTypes to match on
     * @param includeRetired specifies if retired drugs should be included or not
     * @return the list of Drugs
     * @throws APIException
     * @since 1.10
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrugsByMapping(
        code: String?,
        conceptSource: ConceptSource,
        withAnyOfTheseTypes: @JvmSuppressWildcards Collection<ConceptMapType>?,
        includeRetired: Boolean
    ): List<Drug>

    /**
     * Gets the "best" matching drug, i.e. matching the earliest ConceptMapType passed in
     *
     * @param code the code the reference term code to match on
     * @param conceptSource the concept source to match on
     * @param withAnyOfTheseTypesOrOrderOfPreference the ConceptMapTypes to match on
     * @return the Drug
     * @throws APIException
     * @since 1.10
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    @Throws(APIException::class)
    fun getDrugByMapping(
        code: String?,
        conceptSource: ConceptSource,
        withAnyOfTheseTypesOrOrderOfPreference: @JvmSuppressWildcards Collection<ConceptMapType>?
    ): Drug?

    /**
     * An Orderable concept is one where its conceptClass has a mapping in the order_type_class_map
     * table. This method searches for orderable concepts which match the specified arguments
     *
     * @param phrase the phrase to match on
     * @param locales list of locales to match on
     * @param includeRetired include retired concepts or not
     * @param start start index of search results
     * @param length number of concept results to be returned
     * @return List of ConceptSearchResults
     * @since 1.10
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getOrderableConcepts(
        phrase: String?,
        locales: @JvmSuppressWildcards List<Locale>?,
        includeRetired: Boolean,
        start: Int?,
        length: Int?
    ): List<ConceptSearchResult>

    /**
     * @return all ConceptAttributeTypes
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
    fun getAllConceptAttributeTypes(): List<ConceptAttributeType>

    /**
     * Creates or updates the given concept attribute type in the database
     *
     * @param conceptAttributeType
     * @return the ConceptAttributeType created/saved
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_ATTRIBUTE_TYPES)
    fun saveConceptAttributeType(conceptAttributeType: ConceptAttributeType): ConceptAttributeType

    /**
     * @param id
     * @return the ConceptAttributeType with the given internal id
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
    fun getConceptAttributeType(id: Int?): ConceptAttributeType?

    /**
     * @param uuid
     * @return the ConceptAttributeType with the given uuid
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
    fun getConceptAttributeTypeByUuid(uuid: String): ConceptAttributeType?

    /**
     * Completely removes a concept attribute type from the database
     *
     * @param conceptAttributeType
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPT_ATTRIBUTE_TYPES)
    fun purgeConceptAttributeType(conceptAttributeType: ConceptAttributeType)

    /**
     * Find concept attribute types matching the given parameters. Retired types are included in the results
     *
     * @param name (optional) The name of type
     * @return list of ConceptAttributeTypes that matches name partially or completely
     * @throws APIException
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
    @Throws(APIException::class)
    fun getConceptAttributeTypes(name: String?): List<ConceptAttributeType>

    /**
     * Retrieves a ConceptAttributeType object based on the name provided
     *
     * @param exactName
     * @return the ConceptAttributeType with the specified name
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
    fun getConceptAttributeTypeByName(exactName: String): ConceptAttributeType?

    /**
     * Retire a concept attribute type
     *
     * @param conceptAttributeType the concept attribute type to be retired
     * @param reason for retiring the concept attribute type
     * @return the retired concept attribute type
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_ATTRIBUTE_TYPES)
    fun retireConceptAttributeType(conceptAttributeType: ConceptAttributeType, reason: String?): ConceptAttributeType

    /**
     * Un-Retire a concept attribute type
     *
     * @param conceptAttributeType the concept type attribute to unretire
     * @return the unretire concept attribute type
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPT_ATTRIBUTE_TYPES)
    fun unretireConceptAttributeType(conceptAttributeType: ConceptAttributeType): ConceptAttributeType

    /**
     * @param uuid
     * @return the ConceptAttribute with the given uuid
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptAttributeByUuid(uuid: String): ConceptAttribute?

    /**
     * Checks if there are any concept attributes (including voided attributes) for a concept attribute type.
     *
     * @param conceptAttributeType
     * @return boolean true if the concept attribute type is used by a concept
     * @since 2.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun hasAnyConceptAttribute(conceptAttributeType: ConceptAttributeType): Boolean

    /**
     * Creates or updates the given ConceptReferenceRange in the database
     *
     * @param conceptReferenceRange ConceptReferenceRange to save
     * @return the created ConceptReferenceRange
     * @since 2.7.0
     */
    @Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
    fun saveConceptReferenceRange(conceptReferenceRange: ConceptReferenceRange): ConceptReferenceRange

    /**
     * This method gets ConceptReferenceRange by concept id
     *
     * @param conceptId conceptId
     * @return list of ConceptReferenceRange
     * @since 2.7.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptReferenceRangesByConceptId(conceptId: Int?): List<ConceptReferenceRange>

    /**
     * This method gets ConceptReferenceRange by uuid
     *
     * @param uuid uuid
     * @return ConceptReferenceRange
     * @since 2.7.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptReferenceRangeByUuid(uuid: String): ConceptReferenceRange?

    /**
     * Get the appropriate concept reference range for a concept and person
     *
     * @param person The person
     * @param concept The concept
     * @return the matching ConceptReferenceRange object
     * @since 2.7.0
     */
    @Authorized(PrivilegeConstants.GET_CONCEPTS)
    fun getConceptReferenceRange(person: Person, concept: Concept): ConceptReferenceRange?

    /**
     * Completely purge a ConceptReferenceRange from the database.
     *
     * @param conceptReferenceRange The ConceptReferenceRange to remove from the system
     * @since 2.7.0
     */
    @Authorized(PrivilegeConstants.PURGE_CONCEPTS)
    fun purgeConceptReferenceRange(conceptReferenceRange: ConceptReferenceRange)
}
